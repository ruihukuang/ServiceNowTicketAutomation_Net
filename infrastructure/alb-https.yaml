AWSTemplateFormatVersion: '2010-09-09'
Description: 'ALB with cross-account Route53 DNS automation - FIXED'

Parameters:
  EnvironmentName:
    Type: String
    Default: "production"
    Description: "Environment name for tagging"
  
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: "VPC ID for the ALB and Target Group"
  
  PublicSubnetIds:
    Type: CommaDelimitedList
    Description: "Comma separated list of public subnet IDs"
  
  ContainerPort:
    Type: Number
    Default: 8080
    Description: "Container port for the target group"
  
  ALBSecurityGroupId:
    Type: AWS::EC2::SecurityGroup::Id
    Description: "Security Group ID for ALB"
  
  CertificateArn:
    Type: String
    Description: "ARN of the SSL certificate"
  
  DomainNameCustom:
    Type: String
    Default: "v1.prod.servicenow123.click"
    Description: "Custom domain name for the ALB"
  
  CrossAccountRoute53RoleArn:
    Type: String
    Description: "ARN of the IAM role in the DNS account"
    Default: "arn:aws:iam::628125037712:role/AuthenticatedRole"
  
  HostedZoneId:
    Type: String
    Default: "Z0668343T3C4U6RNZGN0"
    Description: "Route53 Hosted Zone ID in the DNS account"
  
  HostedZoneName:
    Type: String
    Default: "servicenow123.click"
    Description: "Route53 Hosted Zone name (must end with dot)"

Resources:
  # 1. ALB Resources
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${EnvironmentName}-alb
      Scheme: internet-facing
      Subnets: !Ref PublicSubnetIds
      SecurityGroups:
        - !Ref ALBSecurityGroupId
      Type: application
      IpAddressType: ipv4
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Name
          Value: !Sub ${EnvironmentName}-alb

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${EnvironmentName}-tg
      VpcId: !Ref VpcId
      Port: !Ref ContainerPort
      Protocol: HTTP
      TargetType: ip
      HealthCheckProtocol: HTTP
      HealthCheckPort: traffic-port
      HealthCheckPath: /
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Matcher:
        HttpCode: "200"
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName

  HTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Protocol: HTTPS
      Port: 443
      SslPolicy: ELBSecurityPolicy-TLS13-1-2-2021-06
      Certificates:
        - CertificateArn: !Ref CertificateArn
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName

  # 2. IAM Role for Lambda - FIXED
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${EnvironmentName}-CrossAccountDNSLambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: AssumeCrossAccountRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: sts:AssumeRole
                Resource: !Ref CrossAccountRoute53RoleArn
        - PolicyName: LambdaBasicExecution
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogGroups
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${EnvironmentName}-CreateDNSRecord:*
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName

  # 3. Lambda Function for DNS Management
  CreateDNSRecordFunction:
    Type: AWS::Lambda::Function
    DependsOn: LambdaExecutionRole
    Properties:
      FunctionName: !Sub ${EnvironmentName}-CreateDNSRecord
      Description: "Creates Route53 DNS records in another account"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      MemorySize: 128
      Code:
        ZipFile: |
          import boto3
          import json
          import time
          import logging
          import cfnresponse
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def assume_role(role_arn, session_name):
              """Assume cross-account role"""
              sts_client = boto3.client('sts')
              response = sts_client.assume_role(
                  RoleArn=role_arn,
                  RoleSessionName=session_name,
                  DurationSeconds=900  # 15 minutes
              )
              return response['Credentials']
          
          def get_route53_client(credentials):
              """Create Route53 client with assumed role credentials"""
              return boto3.client(
                  'route53',
                  aws_access_key_id=credentials['AccessKeyId'],
                  aws_secret_access_key=credentials['SecretAccessKey'],
                  aws_session_token=credentials['SessionToken']
              )
          
          def create_dns_record(route53_client, hosted_zone_id, domain_name, alb_dns_name, alb_hosted_zone_id):
              """Create or update Route53 alias record"""
              # Ensure domain name ends with a dot
              if not domain_name.endswith('.'):
                  domain_name = domain_name + '.'
              
              # Ensure ALB DNS name ends with a dot
              if not alb_dns_name.endswith('.'):
                  alb_dns_name = alb_dns_name + '.'
              
              change_batch = {
                  'Changes': [{
                      'Action': 'UPSERT',
                      'ResourceRecordSet': {
                          'Name': domain_name,
                          'Type': 'A',
                          'AliasTarget': {
                              'HostedZoneId': alb_hosted_zone_id,
                              'DNSName': alb_dns_name,
                              'EvaluateTargetHealth': True
                          }
                      }
                  }]
              }
              
              try:
                  response = route53_client.change_resource_record_sets(
                      HostedZoneId=hosted_zone_id,
                      ChangeBatch=change_batch
                  )
                  logger.info(f"DNS record created/updated: {response['ChangeInfo']['Id']}")
                  return response['ChangeInfo']['Id']
              except Exception as e:
                  logger.error(f"Failed to create DNS record: {str(e)}")
                  raise
          
          def delete_dns_record(route53_client, hosted_zone_id, domain_name, alb_dns_name, alb_hosted_zone_id):
              """Delete Route53 alias record"""
              # Ensure domain name ends with a dot
              if not domain_name.endswith('.'):
                  domain_name = domain_name + '.'
              
              # Ensure ALB DNS name ends with a dot
              if not alb_dns_name.endswith('.'):
                  alb_dns_name = alb_dns_name + '.'
              
              change_batch = {
                  'Changes': [{
                      'Action': 'DELETE',
                      'ResourceRecordSet': {
                          'Name': domain_name,
                          'Type': 'A',
                          'AliasTarget': {
                              'HostedZoneId': alb_hosted_zone_id,
                              'DNSName': alb_dns_name,
                              'EvaluateTargetHealth': True
                          }
                      }
                  }]
              }
              
              try:
                  response = route53_client.change_resource_record_sets(
                      HostedZoneId=hosted_zone_id,
                      ChangeBatch=change_batch
                  )
                  logger.info(f"DNS record deleted: {response['ChangeInfo']['Id']}")
                  return response['ChangeInfo']['Id']
              except Exception as e:
                  logger.error(f"Failed to delete DNS record: {str(e)}")
                  # Don't raise for deletes to allow stack deletion to continue
                  return None
          
          def wait_for_change(route53_client, change_id):
              """Wait for Route53 change to complete"""
              while True:
                  response = route53_client.get_change(Id=change_id)
                  status = response['ChangeInfo']['Status']
                  if status == 'INSYNC':
                      break
                  time.sleep(5)
          
          def lambda_handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              response_data = {}
              
              try:
                  properties = event.get('ResourceProperties', {})
                  request_type = event['RequestType']
                  
                  # Required properties
                  cross_account_role_arn = properties.get('CrossAccountRoleArn')
                  hosted_zone_id = properties.get('HostedZoneId')
                  domain_name = properties.get('DomainName')
                  alb_dns_name = properties.get('ALBDNSName')
                  alb_hosted_zone_id = properties.get('ALBHostedZoneId')
                  
                  # Validate required parameters
                  if not all([cross_account_role_arn, hosted_zone_id, domain_name, alb_dns_name, alb_hosted_zone_id]):
                      raise ValueError("Missing required parameters")
                  
                  # Assume cross-account role
                  credentials = assume_role(cross_account_role_arn, 'DNSManagementLambda')
                  route53_client = get_route53_client(credentials)
                  
                  change_id = None
                  
                  if request_type in ['Create', 'Update']:
                      logger.info(f"Creating/updating DNS record for {domain_name}")
                      change_id = create_dns_record(
                          route53_client, 
                          hosted_zone_id, 
                          domain_name, 
                          alb_dns_name, 
                          alb_hosted_zone_id
                      )
                      
                      # Wait for change to propagate
                      if change_id:
                          wait_for_change(route53_client, change_id)
                      
                      response_data = {
                          'ChangeId': change_id,
                          'DomainName': domain_name,
                          'Message': 'DNS record created successfully'
                      }
                      
                  elif request_type == 'Delete':
                      logger.info(f"Deleting DNS record for {domain_name}")
                      change_id = delete_dns_record(
                          route53_client, 
                          hosted_zone_id, 
                          domain_name, 
                          alb_dns_name, 
                          alb_hosted_zone_id
                      )
                      response_data = {
                          'Message': 'DNS record deletion initiated'
                      }
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  logger.error(f"Error in Lambda function: {str(e)}")
                  response_data = {
                      'Error': str(e)
                  }
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

  # 4. Lambda Function Permissions for Custom Resource - FIXED
  LambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: CreateDNSRecordFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref CreateDNSRecordFunction
      Principal: cloudformation.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Sub arn:aws:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*

  # 5. Custom Resource for DNS Management
  CrossAccountDNSRecord:
    Type: Custom::CrossAccountDNS
    DependsOn: 
      - ApplicationLoadBalancer
      - CreateDNSRecordFunction
      - LambdaPermission
    Properties:
      ServiceToken: !GetAtt CreateDNSRecordFunction.Arn
      CrossAccountRoleArn: !Ref CrossAccountRoute53RoleArn
      HostedZoneId: !Ref HostedZoneId
      DomainName: !Ref DomainNameCustom
      ALBHostedZoneId: !GetAtt ApplicationLoadBalancer.CanonicalHostedZoneID
      ALBDNSName: !GetAtt ApplicationLoadBalancer.DNSName

Outputs:
  ALBDnsName:
    Description: 'ALB DNS Name'
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub ${AWS::StackName}-ALBDnsName
  
  ALBFinalEndpoint:
    Description: 'Final HTTPS endpoint for users'
    Value: !Sub https://${DomainNameCustom}
    Export:
      Name: !Sub ${AWS::StackName}-ALBFinalEndpoint
  
  TargetGroupArn:
    Description: 'Target Group ARN'
    Value: !Ref TargetGroup
    Export:
      Name: !Sub ${AWS::StackName}-TargetGroupArn
  
  ALBCanonicalHostedZoneId:
    Description: 'ALB Canonical Hosted Zone ID'
    Value: !GetAtt ApplicationLoadBalancer.CanonicalHostedZoneID
    Export:
      Name: !Sub ${AWS::StackName}-ALBCanonicalHostedZoneId
  
  DNSRecordStatus:
    Description: 'Cross-account DNS record status'
    Value: !GetAtt CrossAccountDNSRecord.DomainName
    Export:
      Name: !Sub ${AWS::StackName}-DNSRecordStatus