name: Sync GHCR to ECR and Deploy

on:
  push:
    branches: [main, production]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag (default: git SHA)'
        required: false
        type: string
      ghcr_package_name:
        description: 'GHCR Package name'
        required: false
        default: 'servicenowticketautomation_net'
        type: string

permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read 
  packages: read    # Required for pulling from GHCR
  

jobs:
  # 1. ä» GHCR Package åŒæ­¥åˆ° ECR
  sync-to-ecr:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
    
    steps:
    - name: Set up variables
      id: setup-vars
      run: |
        # è®¾ç½®ç¯å¢ƒ
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [ "${{ github.ref_name }}" = "main" ]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="production"
        fi
        
        # è®¾ç½®é•œåƒæ ‡ç­¾
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
        else
          IMAGE_TAG="${{ github.sha }}"
        fi
        
        # è®¾ç½® GHCR package åç§°
        PACKAGE_NAME="servicenowticketautomation_net"

        
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
        echo "ghcr_image=ghcr.io/${{ github.repository_owner }}/$PACKAGE_NAME:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "ghcr_image_latest=ghcr.io/${{ github.repository_owner }}/$PACKAGE_NAME:latest" >> $GITHUB_OUTPUT
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}

    - name: Create ECR repository if needed
      run: |
         ENVIRONMENT="${{ steps.setup-vars.outputs.environment }}"
         REPO_NAME="servicenow-$ENVIRONMENT"
    
         # Check if repository exists, create if it doesn't
         if aws ecr describe-repositories --repository-names "$REPO_NAME" >/dev/null 2>&1; then
            echo "âœ… ECR repository $REPO_NAME already exists"
         else
            echo "ğŸ› ï¸ Creating ECR repository $REPO_NAME"
            aws ecr create-repository \
            --repository-name "$REPO_NAME" \
            --image-tag-mutability MUTABLE \
            --image-scanning-configuration scanOnPush=true
      
            echo "âœ… Created ECR repository $REPO_NAME"
          fi
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        mask-password: 'true' 
    
    - name: Pull from GHCR and push to ECR
      id: sync-image
      run: |
        ENVIRONMENT="${{ steps.setup-vars.outputs.environment }}"
        ECR_REPO="${{ steps.login-ecr.outputs.registry }}/servicenow-$ENVIRONMENT"
        GHCR_IMAGE="${{ steps.setup-vars.outputs.ghcr_image }}"
        GHCR_IMAGE_LATEST="${{ steps.setup-vars.outputs.ghcr_image_latest }}"
        
        echo "ğŸ” Syncing from GHCR to ECR"
        echo "Source: $GHCR_IMAGE"
        echo "Target: $ECR_REPO"
        echo "Package: ${{ steps.setup-vars.outputs.package_name }}"
        
        # ç™»å½•åˆ° GHCR
        echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        # å°è¯•æ‹‰å–æŒ‡å®šæ ‡ç­¾çš„é•œåƒ
        echo "Pulling specific tag from GHCR: $GHCR_IMAGE"
        if docker pull $GHCR_IMAGE; then
          echo "âœ… Successfully pulled $GHCR_IMAGE"
          SOURCE_IMAGE=$GHCR_IMAGE
        else
          echo "âš ï¸ Failed to pull $GHCR_IMAGE, trying latest tag..."
          # å°è¯•æ‹‰å– latest æ ‡ç­¾
          if docker pull $GHCR_IMAGE_LATEST; then
            echo "âœ… Successfully pulled $GHCR_IMAGE_LATEST"
            SOURCE_IMAGE=$GHCR_IMAGE_LATEST
          else
            echo "âŒ Failed to pull image from GHCR"
            echo "Available tags for ghcr.io/${{ github.repository_owner }}/${{ steps.setup-vars.outputs.package_name }}:"
            
            # å°è¯•åˆ—å‡ºå¯ç”¨æ ‡ç­¾ï¼ˆéœ€è¦é€‚å½“çš„æƒé™ï¼‰
            curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/users/${{ github.repository_owner }}/packages/container/${{ steps.setup-vars.outputs.package_name }}/versions" \
              | jq -r '.[].metadata.container.tags[]' 2>/dev/null || echo "Could not list tags"
            
            exit 1
          fi
        fi
        
        # æ‰“æ ‡ç­¾å¹¶æ¨é€åˆ° ECR
        echo "Tagging image for ECR..."
        docker tag $SOURCE_IMAGE $ECR_REPO:${{ steps.setup-vars.outputs.image_tag }}
        docker tag $SOURCE_IMAGE $ECR_REPO:latest
        
        echo "Pushing to ECR..."
        docker push $ECR_REPO:${{ steps.setup-vars.outputs.image_tag }}
        docker push $ECR_REPO:latest
        
        echo "âœ… Successfully synced to ECR"
        echo "ECR_IMAGE=$ECR_REPO:${{ steps.setup-vars.outputs.image_tag }}" >> $GITHUB_ENV
        echo "ECR_REPO=$ECR_REPO" >> $GITHUB_ENV
        echo "SOURCE_IMAGE=$SOURCE_IMAGE" >> $GITHUB_ENV
        
        # è¾“å‡ºä¾›åç»­æ­¥éª¤ä½¿ç”¨
        echo "ecr_image=$ECR_REPO:${{ steps.setup-vars.outputs.image_tag }}" >> $GITHUB_OUTPUT
        echo "ecr_repo=$ECR_REPO" >> $GITHUB_OUTPUT

    - name: Verify ECR image
      run: |
        echo "Verifying ECR image..."
        docker pull ${{ env.ECR_IMAGE }}
        
        docker run -d -p 8081:8080 --name verify-ecr ${{ env.ECR_IMAGE }}
        sleep 20
        
        if curl -f http://localhost:8081/health; then
          echo "âœ… ECR image verified"
        else
          echo "âŒ ECR image verification failed"
          docker logs verify-ecr
          exit 1
        fi
        
        docker stop verify-ecr && docker rm verify-ecr

  # 3. éƒ¨ç½²åŸºç¡€è®¾æ–½ï¼ˆç¬¬ä¸€æ¬¡ï¼‰
  deploy-infrastructure:
    needs: sync-to-ecr
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref_name == 'main'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Deploy CloudFormation Stack
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || 'staging' }}
        STACK_NAME="servicenow-$ENVIRONMENT"
        
        echo "ğŸš€ Deploying infrastructure for $ENVIRONMENT..."
        
        aws cloudformation deploy \
          --stack-name $STACK_NAME \
          --template-file infrastructure/main.yaml \
          --parameter-overrides \
            EnvironmentName=$ENVIRONMENT \
            GitHubUsername=${{ github.repository_owner }} \
            GitHubRepo=${{ github.event.repository.name }} \
            DomainName=api.$ENVIRONMENT.servicenow-automation.com \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset
        
        # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
        echo "â³ Waiting for stack creation..."
        aws cloudformation wait stack-create-complete \
          --stack-name $STACK_NAME \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… Infrastructure deployed successfully!"

  # 4. æ›´æ–° ECS æœåŠ¡ä½¿ç”¨æ–°é•œåƒ
  update-ecs-service:
    needs: [sync-to-ecr, deploy-infrastructure]
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get CloudFormation outputs
      id: cf-outputs
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        STACK_NAME="servicenow-$ENVIRONMENT"
        
        echo "ğŸ“‹ Getting CloudFormation outputs..."
        
        # è·å–æ ˆè¾“å‡º
        OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --query 'Stacks[0].Outputs' \
          --region ${{ env.AWS_REGION }} \
          --output json)
        
        # æå–å…³é”®è¾“å‡º
        CLUSTER_NAME=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSClusterName").OutputValue')
        SERVICE_NAME=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSServiceName").OutputValue')
        ALB_DNS=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ALBDnsName").OutputValue')
        
        echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
        echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
        echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV
        
        echo "âœ… Retrieved CloudFormation outputs:"
        echo "   Cluster: $CLUSTER_NAME"
        echo "   Service: $SERVICE_NAME"
        echo "   ALB DNS: $ALB_DNS"
    
    - name: Update ECS service with new image
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        
        echo "ğŸ”„ Updating ECS service with new image..."
        
        # æ–¹æ³•1ï¼šç›´æ¥æ›´æ–°æœåŠ¡ï¼ˆæœ€ç®€å•ï¼‰
        aws ecs update-service \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… ECS service update initiated"
        
        # æˆ–è€…æ–¹æ³•2ï¼šä½¿ç”¨æ–°ä»»åŠ¡å®šä¹‰ï¼ˆæ›´ç²¾ç¡®æ§åˆ¶ï¼‰
        # è·å–å½“å‰ä»»åŠ¡å®šä¹‰
        # TASK_DEF=$(aws ecs describe-task-definition \
        #   --task-definition servicenow-$ENVIRONMENT-task \
        #   --region ${{ env.AWS_REGION }} \
        #   --query 'taskDefinition' \
        #   --output json)
        #
        # æ›´æ–°é•œåƒå¹¶æ³¨å†Œæ–°ä»»åŠ¡å®šä¹‰
        # ... ç„¶åæ›´æ–°æœåŠ¡ä½¿ç”¨æ–°ä»»åŠ¡å®šä¹‰
    
    - name: Wait for deployment to stabilize
      run: |
        echo "â³ Waiting for ECS deployment to stabilize..."
        
        # ç­‰å¾…æœåŠ¡ç¨³å®š
        aws ecs wait services-stable \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… ECS service stabilized"
        
        # è·å–éƒ¨ç½²çŠ¶æ€
        SERVICE_INFO=$(aws ecs describe-services \
          --cluster ${{ env.CLUSTER_NAME }} \
          --services ${{ env.SERVICE_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0]')
        
        DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
        RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
        DEPLOYMENTS=$(echo $SERVICE_INFO | jq -r '.deployments | length')
        
        echo "ğŸ“Š Deployment Status:"
        echo "   Desired tasks: $DESIRED_COUNT"
        echo "   Running tasks: $RUNNING_COUNT"
        echo "   Active deployments: $DEPLOYMENTS"

  # 5. éªŒè¯éƒ¨ç½²
  verify-deployment:
    needs: update-ecs-service
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
    
    steps:
    - name: Wait for ALB to propagate
      run: |
        echo "â³ Waiting for ALB DNS to propagate and health checks to pass..."
        sleep 60
        echo "âœ… Wait complete"
    
    - name: Test deployment via ALB
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        
        # å¦‚æœ ALB_DNS æ²¡æœ‰è®¾ç½®ï¼Œå°è¯•è·å–
        if [ -z "${{ env.ALB_DNS }}" ]; then
          echo "Retrieving ALB DNS..."
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
            --region ${{ env.AWS_REGION }} \
            --output text | head -1)
        else
          ALB_DNS="${{ env.ALB_DNS }}"
        fi
        
        echo "ğŸ” Testing deployment via ALB: $ALB_DNS"
        
        # æµ‹è¯•å¥åº·ç«¯ç‚¹
        MAX_ATTEMPTS=10
        ATTEMPT=1
        SUCCESS=false
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."
          
          # ä½¿ç”¨ curl æµ‹è¯• HTTPS ç«¯ç‚¹
          RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" "https://$ALB_DNS/health" --max-time 30 2>/dev/null || echo "HTTP_STATUS:000")
          STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
          
          if [ "$STATUS" = "200" ]; then
            echo "âœ… Health check passed: HTTP 200"
            SUCCESS=true
            
            # æµ‹è¯•å…¶ä»–ç«¯ç‚¹
            echo "Testing additional endpoints..."
            
            # æ ¹ç«¯ç‚¹
            ROOT_RESPONSE=$(curl -s "https://$ALB_DNS/" --max-time 10 2>/dev/null || echo "No response")
            if [ -n "$ROOT_RESPONSE" ] && [ "$ROOT_RESPONSE" != "No response" ]; then
              echo "âœ… Root endpoint responded"
            fi
            
            # API ä¿¡æ¯ç«¯ç‚¹
            API_RESPONSE=$(curl -s "https://$ALB_DNS/api/info" --max-time 10 2>/dev/null || echo "No response")
            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "No response" ]; then
              echo "âœ… API info endpoint responded"
            fi
            
            break
          else
            echo "â³ Health check: HTTP $STATUS"
            sleep 15
            ATTEMPT=$((ATTEMPT + 1))
          fi
        done
        
        if [ "$SUCCESS" = false ]; then
          echo "âŒ Deployment verification failed after $MAX_ATTEMPTS attempts"
          
          # è·å– ECS ä»»åŠ¡ä¿¡æ¯å¸®åŠ©è°ƒè¯•
          echo "Fetching ECS task details for debugging..."
          
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --query 'taskArns[0]' \
            --region ${{ env.AWS_REGION }} \
            --output text)
          
          if [ -n "$TASK_ARN" ] && [ "$TASK_ARN" != "None" ]; then
            echo "ğŸ“‹ Task ARN: $TASK_ARN"
            
            # è·å–ä»»åŠ¡çŠ¶æ€
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster ${{ env.CLUSTER_NAME }} \
              --tasks $TASK_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[0].lastStatus' \
              --output text)
            
            echo "ğŸ“Š Task Status: $TASK_STATUS"
            
            # è·å–åœæ­¢åŸå› ï¼ˆå¦‚æœä»»åŠ¡å¤±è´¥ï¼‰
            STOP_REASON=$(aws ecs describe-tasks \
              --cluster ${{ env.CLUSTER_NAME }} \
              --tasks $TASK_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[0].stoppedReason' \
              --output text 2>/dev/null || echo "N/A")
            
            if [ -n "$STOP_REASON" ] && [ "$STOP_REASON" != "None" ]; then
              echo "âš ï¸ Stop Reason: $STOP_REASON"
            fi
          fi
          
          # æ£€æŸ¥ ALB ç›®æ ‡ç»„å¥åº·çŠ¶æ€
          echo "Checking ALB target group health..."
          
          TG_ARN=$(aws elbv2 describe-target-groups \
            --query "TargetGroups[?contains(TargetGroupName, '$ENVIRONMENT')].TargetGroupArn" \
            --region ${{ env.AWS_REGION }} \
            --output text | head -1)
          
          if [ -n "$TG_ARN" ]; then
            TG_HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn $TG_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'TargetHealthDescriptions[].TargetHealth.State' \
              --output json 2>/dev/null || echo "[]")
            
            echo "ğŸ¯ Target Group Health States:"
            echo $TG_HEALTH | jq -r '.[]'
          fi
          
          exit 1
        fi
    
    - name: Run comprehensive tests
      run: |
        ALB_DNS="${{ env.ALB_DNS }}"
        if [ -z "$ALB_DNS" ]; then
          ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
            --region ${{ env.AWS_REGION }} \
            --output text | head -1)
        fi
        
        echo "ğŸ§ª Running comprehensive API tests..."
        
        # æµ‹è¯•å¤šä¸ªç«¯ç‚¹
        ENDPOINTS=(
          "/"
          "/health"
          "/api/info"
        )
        
        ALL_PASSED=true
        
        for endpoint in "${ENDPOINTS[@]}"; do
          URL="https://$ALB_DNS$endpoint"
          echo ""
          echo "Testing: $URL"
          
          # ä½¿ç”¨è¶…æ—¶å’Œé‡è¯•
          for i in {1..3}; do
            RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\nTIME:%{time_total}" \
              "$URL" \
              --max-time 30 \
              --retry 2 \
              --retry-delay 1 \
              2>/dev/null || echo -e "\nHTTP_STATUS:000\nTIME:0")
            
            STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
            TIME=$(echo "$RESPONSE" | grep "TIME:" | cut -d':' -f2)
            BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d' | sed '/TIME:/d')
            
            if [ "$STATUS" = "200" ] || [ "$STATUS" = "201" ] || [ "$STATUS" = "204" ]; then
              echo "âœ… $endpoint: HTTP $STATUS (${TIME}s)"
              if [ -n "$BODY" ]; then
                echo "   Response: $(echo "$BODY" | head -c 100)..."
              fi
              break
            elif [ $i -eq 3 ]; then
              echo "âŒ $endpoint: Failed after 3 attempts (HTTP $STATUS)"
              ALL_PASSED=false
            else
              echo "âš ï¸ $endpoint: Attempt $i failed (HTTP $STATUS), retrying..."
              sleep 2
            fi
          done
        done
        
        if [ "$ALL_PASSED" = true ]; then
          echo ""
          echo "ğŸ‰ All API tests passed!"
        else
          echo ""
          echo "âš ï¸ Some API tests failed"
        fi

  # 6. æ¸…ç†å’Œé€šçŸ¥
  cleanup-and-notify:
    runs-on: ubuntu-latest
    needs: [verify-deployment, deploy-infrastructure, sync-to-ecr]
    if: always()
    
    steps:
    - name: Create deployment summary
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        DEPLOYMENT_STATUS="${{ needs.verify-deployment.result }}"
        CURRENT_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
        echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ğŸ“Š Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: \`$ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: $([ \"$DEPLOYMENT_STATUS\" = \"success\" ] && echo \"âœ… Success\" || echo \"âŒ Failed\")" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp**: $CURRENT_TIME" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Workflow**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ğŸ“¦ Image Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Source**: GHCR" >> $GITHUB_STEP_SUMMARY
        echo "- **GHCR Image**: \`ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **ECR Image**: \`${{ needs.sync-to-ecr.outputs.ecr_image_uri || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "$DEPLOYMENT_STATUS" = "success" ]; then
          echo "### ğŸ”— Access URLs" >> $GITHUB_STEP_SUMMARY
          
          # å°è¯•è·å– ALB DNS
          if [ -n "${{ env.ALB_DNS }}" ]; then
            ALB_DNS="${{ env.ALB_DNS }}"
          else
            # å°è¯•ä» AWS è·å–
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
              --region ${{ env.AWS_REGION }} \
              --output text 2>/dev/null | head -1 || echo "Not available")
          fi
          
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "Not available" ]; then
            echo "- **API Endpoint**: [https://$ALB_DNS](https://$ALB_DNS)" >> $GITHUB_STEP_SUMMARY
            echo "- **Health Check**: [https://$ALB_DNS/health](https://$ALB_DNS/health)" >> $GITHUB_STEP_SUMMARY
            echo "- **API Info**: [https://$ALB_DNS/api/info](https://$ALB_DNS/api/info)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **API Endpoint**: Not available yet" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ—ï¸ Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Cluster**: \`${{ env.CLUSTER_NAME || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service**: \`${{ env.SERVICE_NAME || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFormation Stack**: \`servicenow-$ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ“ˆ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Monitor application logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
          echo "2. Check ECS service metrics in AWS Console" >> $GITHUB_STEP_SUMMARY
          echo "3. Set up alerts for service health" >> $GITHUB_STEP_SUMMARY
          echo "4. Configure auto-scaling if needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "ğŸ‰ **Deployment successful!** The application is now live and serving traffic." >> $GITHUB_STEP_SUMMARY
        else
          echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Possible issues:**" >> $GITHUB_STEP_SUMMARY
          echo "1. CloudFormation stack deployment failed" >> $GITHUB_STEP_SUMMARY
          echo "2. ECS task failed to start" >> $GITHUB_STEP_SUMMARY
          echo "3. ALB health checks failing" >> $GITHUB_STEP_SUMMARY
          echo "4. Network connectivity issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Troubleshooting steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Check CloudFormation stack events" >> $GITHUB_STEP_SUMMARY
          echo "2. Review ECS task logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify ALB target group health" >> $GITHUB_STEP_SUMMARY
          echo "4. Check security group configurations" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Please check the logs above for detailed error messages.**" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "*Deployment completed at $CURRENT_TIME*" >> $GITHUB_STEP_SUMMARY
    
    - name: Send Slack notification (optional)
      if: always()
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        if [ -n "$SLACK_WEBHOOK_URL" ]; then
          ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
          DEPLOYMENT_STATUS="${{ needs.verify-deployment.result }}"
          COMMIT_LINK="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          WORKFLOW_LINK="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ "$DEPLOYMENT_STATUS" = "success" ]; then
            EMOJI="ğŸš€"
            COLOR="good"
            TITLE="Deployment Successful"
            MESSAGE="Successfully deployed to *$ENVIRONMENT*"
          else
            EMOJI="âš ï¸"
            COLOR="danger"
            TITLE="Deployment Failed"
            MESSAGE="Failed to deploy to *$ENVIRONMENT*"
          fi
          
          PAYLOAD=$(cat << EOF
          {
            "attachments": [
              {
                "color": "$COLOR",
                "title": "$EMOJI $TITLE",
                "fields": [
                  {
                    "title": "Environment",
                    "value": "$ENVIRONMENT",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "$DEPLOYMENT_STATUS",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "<$COMMIT_LINK|${GITHUB_SHA:0:7}>",
                    "short": true
                  },
                  {
                    "title": "Triggered by",
                    "value": "${{ github.actor }}",
                    "short": true
                  }
                ],
                "footer": "GitHub Actions",
                "ts": $(date +%s),
                "actions": [
                  {
                    "type": "button",
                    "text": "View Workflow",
                    "url": "$WORKFLOW_LINK",
                    "style": "primary"
                  },
                  {
                    "type": "button",
                    "text": "View Commit",
                    "url": "$COMMIT_LINK"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          curl -X POST -H 'Content-type: application/json' --data "$PAYLOAD" $SLACK_WEBHOOK_URL
          echo "Slack notification sent"
        else
          echo "Slack webhook not configured, skipping notification"
        fi
    
    - name: Clean up Docker images
      if: always()
      run: |
        echo "ğŸ§¹ Cleaning up Docker images..."
        
        # åˆ é™¤æµ‹è¯•å®¹å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        docker rm -f test-app verify-ecr 2>/dev/null || true
        
        # æ¸…ç†æœªä½¿ç”¨çš„é•œåƒ
        docker image prune -a -f
        
        echo "âœ… Cleanup complete"

# 7. å›æ»šä½œä¸šï¼ˆæ‰‹åŠ¨è§¦å‘ï¼‰
  rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback'
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Rollback to previous task definition
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || 'production' }}
        
        echo "ğŸ”™ Rolling back ECS service in $ENVIRONMENT..."
        
        # è·å–å½“å‰æœåŠ¡ä¿¡æ¯
        CLUSTER_NAME="servicenow-$ENVIRONMENT-cluster"
        SERVICE_NAME="servicenow-$ENVIRONMENT-service"
        
        # è·å–å…ˆå‰çš„ä»»åŠ¡å®šä¹‰
        PREVIOUS_TASK_DEF=$(aws ecs describe-services \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0].deployments[?status==\"PRIMARY\"].taskDefinition' \
          --output text)
        
        if [ -n "$PREVIOUS_TASK_DEF" ]; then
          echo "Rolling back to: $PREVIOUS_TASK_DEF"
          
          # æ›´æ–°æœåŠ¡ä½¿ç”¨å…ˆå‰çš„ä»»åŠ¡å®šä¹‰
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $PREVIOUS_TASK_DEF \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Rollback initiated"
        else
          echo "âŒ No previous task definition found for rollback"
          exit 1
        fi
    
    - name: Wait for rollback to complete
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || 'production' }}
        CLUSTER_NAME="servicenow-$ENVIRONMENT-cluster"
        SERVICE_NAME="servicenow-$ENVIRONMENT-service"
        
        echo "â³ Waiting for rollback to stabilize..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… Rollback completed successfully"