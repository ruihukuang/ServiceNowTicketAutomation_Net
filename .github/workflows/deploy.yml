name: Sync GHCR to ECR and Deploy

on:
  workflow_dispatch:


permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read 
  packages: read    # Required for pulling from GHCR

env:
  ECR_REGISTRY: public.ecr.aws
  ECR_REPOSITORY: ${{ secrets.RESPOSITORY_NAME }} 
  #TEMPLATE_BUCKET: "my-cfn-templates-bucket-7-12-2025"
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EnvironmentName: production

jobs:
  build-push-to-ecr:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}
    
    - name: Log in to Amazon ECR
      run: |
        docker logout public.ecr.aws
        aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

    - name: Check if ECR Repository Exists
      id: check_repo
      run: |
        if aws ecr-public describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region us-east-1 ; then
          echo "repository_exists=true" >> $GITHUB_ENV
        else
          echo "repository_exists=false" >> $GITHUB_ENV
        fi
        
    - name: Create a Public ECR Repository for Model Artifacts if it does not exist
      if: env.repository_exists == 'false'
      run: |
        aws ecr-public create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region us-east-1
    
    - name: check if an docker image  exists and act accordingly
      run: |
        output=$(aws ecr-public describe-images --repository-name ${{ env.ECR_REPOSITORY }} --region us-east-1 )
        matching_images=$(echo "$output" | jq -r '.imageDetails[].imageTags[] | select(endswith("_servicenow"))')

        # Check if any matching images were found
        if [ -n "$matching_images" ]; then
          echo "Found images with tags ending in _servicenow:"
          echo "$matching_images"
              # Loop through each matching image tag and delete it
          # for tag in $matching_images; do
          #   aws ecr-public batch-delete-image --repository-name ${{ env.ECR_REPOSITORY }} --region us-east-1 --image-ids imageTag="$tag"
          # done
         echo "images_exists=true" >> $GITHUB_ENV
         echo "FULL_IMAGE_NAME=$matching_images" >> $GITHUB_ENV
         else
           echo "No images found with tags ending in _servicenow."
           echo "images_exists=false" >> $GITHUB_ENV
        fi
        
    - name: Build, tag, and push image to Amazon ECR if an docker image does not exist
      env:
        IMAGE_TAG: ${{ github.sha }}_servicenow
      if: env.images_exists == 'false'
      run: |
        docker build -t $IMAGE_TAG  .
        docker tag $IMAGE_TAG ${{ env.ECR_REGISTRY }}/g1n7j8p0/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        docker push ${{ env.ECR_REGISTRY }}/g1n7j8p0/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG

        FULL_IMAGE_NAME="${{ env.ECR_REGISTRY }}/g1n7j8p0/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

        # Set output for the next step
        echo "FULL_IMAGE_NAME=$FULL_IMAGE_NAME" >> $GITHUB_ENV


    # - name: Verify ECR image
    #   env:
    #     ECR_REGISTRY: public.ecr.aws/g1n7j8p0  # Your public ECR registry
    #     ECR_REPOSITORY: servicenow_repo  # Your repository name
    #     IMAGE_TAG: $FULL_IMAGE_NAME  # Your tag format
    #   run: |
    #     echo "ğŸ”„ Logging into Public ECR..."
    #     aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

    #     echo "Verifying ECR image..."
    #     docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$FULL_IMAGE_NAME
        
    #     docker run -d -p 8081:8080 --name verify-ecr $ECR_REGISTRY/$ECR_REPOSITORY:$FULL_IMAGE_NAME
    #     sleep 60
        
    #     if curl -f http://localhost:8081/health; then
    #       echo "âœ… ECR image verified"
    #     else
    #       echo "âŒ ECR image verification failed"
    #       docker logs verify-ecr
    #       exit 1
    #     fi
        
    #     docker stop verify-ecr && docker rm verify-ecr

  # 2. éƒ¨ç½²åŸºç¡€è®¾æ–½ VPCï¼ˆç¬¬ä¸€æ¬¡ï¼‰
  deploy-infrastructure-vpc-stack:
    needs: build-push-to-ecr
    runs-on: ubuntu-latest

    steps:

    - name: Checkout repository
      uses: actions/checkout@v2
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}

    # - name: Upload Nested Templates to S3
    #   run: |
    #     echo "ğŸ“¤ Uploading nested CloudFormation templates to S3..."
        
    #     # Create S3 bucket if it doesn't exist
    #     if ! aws s3api head-bucket --bucket $TEMPLATE_BUCKET 2>/dev/null; then
    #       echo "ğŸª£ Creating S3 bucket: $TEMPLATE_BUCKET"
    #       aws s3api create-bucket \
    #         --bucket $TEMPLATE_BUCKET \
    #         --region $AWS_REGION \
    #         --create-bucket-configuration LocationConstraint=$AWS_REGION

    #           # Apply bucket policy using AWS CLI
    #          aws s3api put-bucket-policy \
    #            --bucket $TEMPLATE_BUCKET \
    #            --policy "{
    #                 \"Version\": \"2012-10-17\",
    #                 \"Statement\": [
    #                 {
    #                  \"Effect\": \"Allow\",
    #                   \"Principal\": {
    #                   \"Service\": \"cloudformation.amazonaws.com\"
    #                 },
    #                 \"Action\": \"s3:GetObject\",
    #                 \"Resource\": \"arn:aws:s3:::${TEMPLATE_BUCKET}/*\"
    #               }
    #             ]
    #           }"
  
    #      fi

    #     # Upload all nested templates
    #     echo "ğŸ“„ Uploading vpc-isolated.yaml..."
    #     aws s3 cp infrastructure/vpc-isolated.yaml s3://$TEMPLATE_BUCKET/vpc-isolated.yaml \
    #       --content-type "text/yaml" \
    #       --cache-control "max-age=0, no-cache"
        
    #     echo "ğŸ“„ Uploading ecs-cluster-vpce.yaml..."
    #     aws s3 cp infrastructure/ecs-cluster-vpce.yaml s3://$TEMPLATE_BUCKET/ecs-cluster-vpce.yaml \
    #       --content-type "text/yaml" \
    #       --cache-control "max-age=0, no-cache"
        
    #     echo "ğŸ“„ Uploading alb-https.yaml..."
    #     aws s3 cp infrastructure/alb-https.yaml s3://$TEMPLATE_BUCKET/alb-https.yaml \
    #       --content-type "text/yaml" \
    #       --cache-control "max-age=0, no-cache"
        
    #     echo "ğŸ“„ Uploading ecs-service-private.yaml..."
    #     aws s3 cp infrastructure/ecs-service-private.yaml s3://$TEMPLATE_BUCKET/ecs-service-private.yaml \
    #       --content-type "text/yaml" \
    #       --cache-control "max-age=0, no-cache"
        
    #     # Verify uploads
    #     echo "âœ… Verifying uploads..."
    #     aws s3 ls s3://$TEMPLATE_BUCKET/ --recursive --human-readable
    
    - name: Deploy CloudFormation VPC Stack
      env:
        STACK_NAME: "VPC-Stack"
      run: |
        
        echo "ğŸš€ Deploying infrastructure for production..."
        
        aws cloudformation deploy \
          --stack-name $STACK_NAME \
          --template-file infrastructure/vpc-isolated.yaml \
          --parameter-overrides \
            EnvironmentName=$EnvironmentName \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ secrets.REGION }} \
          --no-fail-on-empty-changeset
        
        # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
        echo "â³ Waiting for stack creation..."
        aws cloudformation wait stack-create-complete \
          --stack-name $STACK_NAME  \
          --region ${{ secrets.REGION }}
        
        echo "âœ… Infrastructure $STACK_NAME deployed successfully!"

  # 3. éƒ¨ç½²åŸºç¡€è®¾æ–½ ECS Clusterï¼ˆç¬¬ä¸€æ¬¡ï¼‰
  deploy-infrastructure-ecs-stack:
    needs: build-push-to-ecr
    runs-on: ubuntu-latest

    steps:

    - name: Checkout repository
      uses: actions/checkout@v2
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}

    - name: Deploy CloudFormation ECS cluster Stack
      env:
        STACK_NAME: "ECS-Cluster-Stack"
      run: |
        
        echo "ğŸš€ Deploying infrastructure for production..."

          # Get outputs from VPC stack
        VPC_ID=$(aws cloudformation describe-stacks \
          --stack-name servicenow-vpc-production \
          --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        PRIVATE_SUBNETS=$(aws cloudformation describe-stacks \
          --stack-name servicenow-vpc-production \
          --query "Stacks[0].Outputs[?OutputKey=='PrivateSubnetIds'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        ECS_SG_ID=$(aws cloudformation describe-stacks \
          --stack-name servicenow-vpc-production \
          --query "Stacks[0].Outputs[?OutputKey=='ECSSecurityGroupId'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        PRIVATE_RT_ID=$(aws cloudformation describe-stacks \
          --stack-name servicenow-vpc-production \
          --query "Stacks[0].Outputs[?OutputKey=='PrivateRouteTableId'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        echo "ğŸ“Š Retrieved parameters:"
        echo "VPC ID: $VPC_ID"
        echo "Private Subnets: $PRIVATE_SUBNETS"
        echo "ECS Security Group: $ECS_SG_ID"
        echo "Private Route Table: $PRIVATE_RT_ID"
        
        aws cloudformation deploy \
          --stack-name $ECS_CLUSTER_STACK_NAME \
          --template-file infrastructure/ecs-cluster-vpce.yaml \
          --parameter-overrides \
            EnvironmentName=$ENVIRONMENT \
            VpcId=$VPC_ID \
            PrivateSubnetIds=$PRIVATE_SUBNETS \
            ECSSecurityGroupId=$ECS_SG_ID \
            PrivateRouteTableId=$PRIVATE_RT_ID \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --region $AWS_REGION \
            --no-fail-on-empty-changeset
        
        # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
        echo "â³ Waiting for stack creation..."
        aws cloudformation wait stack-create-complete \
          --stack-name $STACK_NAME  \
          --region ${{ secrets.REGION }}
        
        echo "âœ… Infrastructure $STACK_NAME deployed successfully!"    


  # 4. æ›´æ–° ECS æœåŠ¡ä½¿ç”¨æ–°é•œåƒ
  update-ecs-service:
    needs: [build-push-to-ecr, deploy-infrastructure]
    runs-on: ubuntu-latest

    
    steps:
    
    - name: Get CloudFormation outputs
      id: cf-outputs
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        STACK_NAME="servicenow-$ENVIRONMENT"
        
        echo "ğŸ“‹ Getting CloudFormation outputs..."
        
        # è·å–æ ˆè¾“å‡º
        OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --query 'Stacks[0].Outputs' \
          --region ${{ env.AWS_REGION }} \
          --output json)
        
        # æå–å…³é”®è¾“å‡º
        CLUSTER_NAME=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSClusterName").OutputValue')
        SERVICE_NAME=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSServiceName").OutputValue')
        ALB_DNS=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ALBDnsName").OutputValue')
        
        echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
        echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
        echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV
        
        echo "âœ… Retrieved CloudFormation outputs:"
        echo "   Cluster: $CLUSTER_NAME"
        echo "   Service: $SERVICE_NAME"
        echo "   ALB DNS: $ALB_DNS"
    
    - name: Update ECS service with new image
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        
        echo "ğŸ”„ Updating ECS service with new image..."
        
        # æ–¹æ³•1ï¼šç›´æ¥æ›´æ–°æœåŠ¡ï¼ˆæœ€ç®€å•ï¼‰
        aws ecs update-service \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… ECS service update initiated"
        
        # æˆ–è€…æ–¹æ³•2ï¼šä½¿ç”¨æ–°ä»»åŠ¡å®šä¹‰ï¼ˆæ›´ç²¾ç¡®æ§åˆ¶ï¼‰
        # è·å–å½“å‰ä»»åŠ¡å®šä¹‰
        # TASK_DEF=$(aws ecs describe-task-definition \
        #   --task-definition servicenow-$ENVIRONMENT-task \
        #   --region ${{ env.AWS_REGION }} \
        #   --query 'taskDefinition' \
        #   --output json)
        #
        # æ›´æ–°é•œåƒå¹¶æ³¨å†Œæ–°ä»»åŠ¡å®šä¹‰
        # ... ç„¶åæ›´æ–°æœåŠ¡ä½¿ç”¨æ–°ä»»åŠ¡å®šä¹‰
    
    - name: Wait for deployment to stabilize
      run: |
        echo "â³ Waiting for ECS deployment to stabilize..."
        
        # ç­‰å¾…æœåŠ¡ç¨³å®š
        aws ecs wait services-stable \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… ECS service stabilized"
        
        # è·å–éƒ¨ç½²çŠ¶æ€
        SERVICE_INFO=$(aws ecs describe-services \
          --cluster ${{ env.CLUSTER_NAME }} \
          --services ${{ env.SERVICE_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0]')
        
        DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
        RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
        DEPLOYMENTS=$(echo $SERVICE_INFO | jq -r '.deployments | length')
        
        echo "ğŸ“Š Deployment Status:"
        echo "   Desired tasks: $DESIRED_COUNT"
        echo "   Running tasks: $RUNNING_COUNT"
        echo "   Active deployments: $DEPLOYMENTS"

  # 5. éªŒè¯éƒ¨ç½²
  verify-deployment:
    needs: update-ecs-service
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
    
    steps:
    - name: Wait for ALB to propagate
      run: |
        echo "â³ Waiting for ALB DNS to propagate and health checks to pass..."
        sleep 60
        echo "âœ… Wait complete"
    
    - name: Test deployment via ALB
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        
        # å¦‚æœ ALB_DNS æ²¡æœ‰è®¾ç½®ï¼Œå°è¯•è·å–
        if [ -z "${{ env.ALB_DNS }}" ]; then
          echo "Retrieving ALB DNS..."
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
            --region ${{ env.AWS_REGION }} \
            --output text | head -1)
        else
          ALB_DNS="${{ env.ALB_DNS }}"
        fi
        
        echo "ğŸ” Testing deployment via ALB: $ALB_DNS"
        
        # æµ‹è¯•å¥åº·ç«¯ç‚¹
        MAX_ATTEMPTS=10
        ATTEMPT=1
        SUCCESS=false
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."
          
          # ä½¿ç”¨ curl æµ‹è¯• HTTPS ç«¯ç‚¹
          RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" "https://$ALB_DNS/health" --max-time 30 2>/dev/null || echo "HTTP_STATUS:000")
          STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
          
          if [ "$STATUS" = "200" ]; then
            echo "âœ… Health check passed: HTTP 200"
            SUCCESS=true
            
            # æµ‹è¯•å…¶ä»–ç«¯ç‚¹
            echo "Testing additional endpoints..."
            
            # æ ¹ç«¯ç‚¹
            ROOT_RESPONSE=$(curl -s "https://$ALB_DNS/" --max-time 10 2>/dev/null || echo "No response")
            if [ -n "$ROOT_RESPONSE" ] && [ "$ROOT_RESPONSE" != "No response" ]; then
              echo "âœ… Root endpoint responded"
            fi
            
            # API ä¿¡æ¯ç«¯ç‚¹
            API_RESPONSE=$(curl -s "https://$ALB_DNS/api/info" --max-time 10 2>/dev/null || echo "No response")
            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "No response" ]; then
              echo "âœ… API info endpoint responded"
            fi
            
            break
          else
            echo "â³ Health check: HTTP $STATUS"
            sleep 15
            ATTEMPT=$((ATTEMPT + 1))
          fi
        done
        
        if [ "$SUCCESS" = false ]; then
          echo "âŒ Deployment verification failed after $MAX_ATTEMPTS attempts"
          
          # è·å– ECS ä»»åŠ¡ä¿¡æ¯å¸®åŠ©è°ƒè¯•
          echo "Fetching ECS task details for debugging..."
          
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --query 'taskArns[0]' \
            --region ${{ env.AWS_REGION }} \
            --output text)
          
          if [ -n "$TASK_ARN" ] && [ "$TASK_ARN" != "None" ]; then
            echo "ğŸ“‹ Task ARN: $TASK_ARN"
            
            # è·å–ä»»åŠ¡çŠ¶æ€
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster ${{ env.CLUSTER_NAME }} \
              --tasks $TASK_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[0].lastStatus' \
              --output text)
            
            echo "ğŸ“Š Task Status: $TASK_STATUS"
            
            # è·å–åœæ­¢åŸå› ï¼ˆå¦‚æœä»»åŠ¡å¤±è´¥ï¼‰
            STOP_REASON=$(aws ecs describe-tasks \
              --cluster ${{ env.CLUSTER_NAME }} \
              --tasks $TASK_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[0].stoppedReason' \
              --output text 2>/dev/null || echo "N/A")
            
            if [ -n "$STOP_REASON" ] && [ "$STOP_REASON" != "None" ]; then
              echo "âš ï¸ Stop Reason: $STOP_REASON"
            fi
          fi
          
          # æ£€æŸ¥ ALB ç›®æ ‡ç»„å¥åº·çŠ¶æ€
          echo "Checking ALB target group health..."
          
          TG_ARN=$(aws elbv2 describe-target-groups \
            --query "TargetGroups[?contains(TargetGroupName, '$ENVIRONMENT')].TargetGroupArn" \
            --region ${{ env.AWS_REGION }} \
            --output text | head -1)
          
          if [ -n "$TG_ARN" ]; then
            TG_HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn $TG_ARN \
              --region ${{ env.AWS_REGION }} \
              --query 'TargetHealthDescriptions[].TargetHealth.State' \
              --output json 2>/dev/null || echo "[]")
            
            echo "ğŸ¯ Target Group Health States:"
            echo $TG_HEALTH | jq -r '.[]'
          fi
          
          exit 1
        fi
    
    - name: Run comprehensive tests
      run: |
        ALB_DNS="${{ env.ALB_DNS }}"
        if [ -z "$ALB_DNS" ]; then
          ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
            --region ${{ env.AWS_REGION }} \
            --output text | head -1)
        fi
        
        echo "ğŸ§ª Running comprehensive API tests..."
        
        # æµ‹è¯•å¤šä¸ªç«¯ç‚¹
        ENDPOINTS=(
          "/"
          "/health"
          "/api/info"
        )
        
        ALL_PASSED=true
        
        for endpoint in "${ENDPOINTS[@]}"; do
          URL="https://$ALB_DNS$endpoint"
          echo ""
          echo "Testing: $URL"
          
          # ä½¿ç”¨è¶…æ—¶å’Œé‡è¯•
          for i in {1..3}; do
            RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\nTIME:%{time_total}" \
              "$URL" \
              --max-time 30 \
              --retry 2 \
              --retry-delay 1 \
              2>/dev/null || echo -e "\nHTTP_STATUS:000\nTIME:0")
            
            STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
            TIME=$(echo "$RESPONSE" | grep "TIME:" | cut -d':' -f2)
            BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d' | sed '/TIME:/d')
            
            if [ "$STATUS" = "200" ] || [ "$STATUS" = "201" ] || [ "$STATUS" = "204" ]; then
              echo "âœ… $endpoint: HTTP $STATUS (${TIME}s)"
              if [ -n "$BODY" ]; then
                echo "   Response: $(echo "$BODY" | head -c 100)..."
              fi
              break
            elif [ $i -eq 3 ]; then
              echo "âŒ $endpoint: Failed after 3 attempts (HTTP $STATUS)"
              ALL_PASSED=false
            else
              echo "âš ï¸ $endpoint: Attempt $i failed (HTTP $STATUS), retrying..."
              sleep 2
            fi
          done
        done
        
        if [ "$ALL_PASSED" = true ]; then
          echo ""
          echo "ğŸ‰ All API tests passed!"
        else
          echo ""
          echo "âš ï¸ Some API tests failed"
        fi

  # 6. æ¸…ç†å’Œé€šçŸ¥
  cleanup-and-notify:
    runs-on: ubuntu-latest
    needs: [verify-deployment, deploy-infrastructure, build-push-to-ecr]
    if: always()
    
    steps:
    - name: Create deployment summary
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        DEPLOYMENT_STATUS="${{ needs.verify-deployment.result }}"
        CURRENT_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
        echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ğŸ“Š Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: \`$ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: $([ \"$DEPLOYMENT_STATUS\" = \"success\" ] && echo \"âœ… Success\" || echo \"âŒ Failed\")" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp**: $CURRENT_TIME" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Workflow**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ğŸ“¦ Image Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Source**: GHCR" >> $GITHUB_STEP_SUMMARY
        echo "- **GHCR Image**: \`ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **ECR Image**: \`${{ needs.sync-to-ecr.outputs.ecr_image_uri || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "$DEPLOYMENT_STATUS" = "success" ]; then
          echo "### ğŸ”— Access URLs" >> $GITHUB_STEP_SUMMARY
          
          # å°è¯•è·å– ALB DNS
          if [ -n "${{ env.ALB_DNS }}" ]; then
            ALB_DNS="${{ env.ALB_DNS }}"
          else
            # å°è¯•ä» AWS è·å–
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
              --region ${{ env.AWS_REGION }} \
              --output text 2>/dev/null | head -1 || echo "Not available")
          fi
          
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "Not available" ]; then
            echo "- **API Endpoint**: [https://$ALB_DNS](https://$ALB_DNS)" >> $GITHUB_STEP_SUMMARY
            echo "- **Health Check**: [https://$ALB_DNS/health](https://$ALB_DNS/health)" >> $GITHUB_STEP_SUMMARY
            echo "- **API Info**: [https://$ALB_DNS/api/info](https://$ALB_DNS/api/info)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **API Endpoint**: Not available yet" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ—ï¸ Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Cluster**: \`${{ env.CLUSTER_NAME || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service**: \`${{ env.SERVICE_NAME || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFormation Stack**: \`servicenow-$ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ“ˆ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Monitor application logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
          echo "2. Check ECS service metrics in AWS Console" >> $GITHUB_STEP_SUMMARY
          echo "3. Set up alerts for service health" >> $GITHUB_STEP_SUMMARY
          echo "4. Configure auto-scaling if needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "ğŸ‰ **Deployment successful!** The application is now live and serving traffic." >> $GITHUB_STEP_SUMMARY
        else
          echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Possible issues:**" >> $GITHUB_STEP_SUMMARY
          echo "1. CloudFormation stack deployment failed" >> $GITHUB_STEP_SUMMARY
          echo "2. ECS task failed to start" >> $GITHUB_STEP_SUMMARY
          echo "3. ALB health checks failing" >> $GITHUB_STEP_SUMMARY
          echo "4. Network connectivity issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Troubleshooting steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Check CloudFormation stack events" >> $GITHUB_STEP_SUMMARY
          echo "2. Review ECS task logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify ALB target group health" >> $GITHUB_STEP_SUMMARY
          echo "4. Check security group configurations" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Please check the logs above for detailed error messages.**" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "*Deployment completed at $CURRENT_TIME*" >> $GITHUB_STEP_SUMMARY
    
    - name: Send Slack notification (optional)
      if: always()
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        if [ -n "$SLACK_WEBHOOK_URL" ]; then
          ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
          DEPLOYMENT_STATUS="${{ needs.verify-deployment.result }}"
          COMMIT_LINK="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          WORKFLOW_LINK="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ "$DEPLOYMENT_STATUS" = "success" ]; then
            EMOJI="ğŸš€"
            COLOR="good"
            TITLE="Deployment Successful"
            MESSAGE="Successfully deployed to *$ENVIRONMENT*"
          else
            EMOJI="âš ï¸"
            COLOR="danger"
            TITLE="Deployment Failed"
            MESSAGE="Failed to deploy to *$ENVIRONMENT*"
          fi
          
          PAYLOAD=$(cat << EOF
          {
            "attachments": [
              {
                "color": "$COLOR",
                "title": "$EMOJI $TITLE",
                "fields": [
                  {
                    "title": "Environment",
                    "value": "$ENVIRONMENT",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "$DEPLOYMENT_STATUS",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "<$COMMIT_LINK|${GITHUB_SHA:0:7}>",
                    "short": true
                  },
                  {
                    "title": "Triggered by",
                    "value": "${{ github.actor }}",
                    "short": true
                  }
                ],
                "footer": "GitHub Actions",
                "ts": $(date +%s),
                "actions": [
                  {
                    "type": "button",
                    "text": "View Workflow",
                    "url": "$WORKFLOW_LINK",
                    "style": "primary"
                  },
                  {
                    "type": "button",
                    "text": "View Commit",
                    "url": "$COMMIT_LINK"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          curl -X POST -H 'Content-type: application/json' --data "$PAYLOAD" $SLACK_WEBHOOK_URL
          echo "Slack notification sent"
        else
          echo "Slack webhook not configured, skipping notification"
        fi
    
    - name: Clean up Docker images
      if: always()
      run: |
        echo "ğŸ§¹ Cleaning up Docker images..."
        
        # åˆ é™¤æµ‹è¯•å®¹å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        docker rm -f test-app verify-ecr 2>/dev/null || true
        
        # æ¸…ç†æœªä½¿ç”¨çš„é•œåƒ
        docker image prune -a -f
        
        echo "âœ… Cleanup complete"

# 7. å›æ»šä½œä¸šï¼ˆæ‰‹åŠ¨è§¦å‘ï¼‰
  rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback'
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Rollback to previous task definition
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || 'production' }}
        
        echo "ğŸ”™ Rolling back ECS service in $ENVIRONMENT..."
        
        # è·å–å½“å‰æœåŠ¡ä¿¡æ¯
        CLUSTER_NAME="servicenow-$ENVIRONMENT-cluster"
        SERVICE_NAME="servicenow-$ENVIRONMENT-service"
        
        # è·å–å…ˆå‰çš„ä»»åŠ¡å®šä¹‰
        PREVIOUS_TASK_DEF=$(aws ecs describe-services \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0].deployments[?status==\"PRIMARY\"].taskDefinition' \
          --output text)
        
        if [ -n "$PREVIOUS_TASK_DEF" ]; then
          echo "Rolling back to: $PREVIOUS_TASK_DEF"
          
          # æ›´æ–°æœåŠ¡ä½¿ç”¨å…ˆå‰çš„ä»»åŠ¡å®šä¹‰
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $PREVIOUS_TASK_DEF \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Rollback initiated"
        else
          echo "âŒ No previous task definition found for rollback"
          exit 1
        fi
    
    - name: Wait for rollback to complete
      run: |
        ENVIRONMENT=${{ github.event.inputs.environment || 'production' }}
        CLUSTER_NAME="servicenow-$ENVIRONMENT-cluster"
        SERVICE_NAME="servicenow-$ENVIRONMENT-service"
        
        echo "â³ Waiting for rollback to stabilize..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… Rollback completed successfully"