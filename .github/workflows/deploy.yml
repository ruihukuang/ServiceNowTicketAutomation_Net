name: Sync GHCR to ECR and Deploy

on:
  workflow_dispatch:


permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read 
  packages: read    # Required for pulling from GHCR

env:
  ECR_REPOSITORY: ${{ secrets.RESPOSITORY_NAME }} 
  #TEMPLATE_BUCKET: "my-cfn-templates-bucket-7-12-2025"
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EnvironmentName: production
  VPC_STACK: "VPC-Stack"
  ECS_CLUSTER_STACK: "ECS-Cluster-Stack"
  Route53_STACK: "Route53-Stack"
  Application_Load_Balancer_STACK: "Application-Load-Balancer-Stack"
  ECS_SERVICE_STACK: "ECS-Service-Stack"

jobs:
  # build-push-to-ecr:
  #   runs-on: ubuntu-latest
    
  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2
    
  #   - name: Configure AWS Credentials
  #     uses: aws-actions/configure-aws-credentials@v1
  #     with:
  #       role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
  #       aws-region: ${{ secrets.REGION }}
    
  #   - name: Login to Amazon ECR Private Registry
  #     run: |
  #       # Get ECR registry ID from account ID
  #       ECR_REGISTRY=${{ secrets.ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
  #       echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV

  #       # Login to private ECR
  #       aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
  #       docker login --username AWS --password-stdin $ECR_REGISTRY

  #   - name: Check if ECR Private Repository Exists
  #     id: check_repo
  #     run: |
  #       if aws ecr describe-repositories \
  #          --repository-names ${{ env.ECR_REPOSITORY }} \
  #          --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
  #          echo "repository_exists=true" >> $GITHUB_ENV
  #       else
  #          echo "repository_exists=false" >> $GITHUB_ENV
  #       fi
        
  #   - name: Create Private ECR Repository if it does not exist
  #     if: env.repository_exists == 'false'
  #     run: |
  #        aws ecr create-repository \
  #          --repository-name ${{ env.ECR_REPOSITORY }} \
  #          --region ${{ env.AWS_REGION }}
    
  #   - name: check if an docker image  exists and act accordingly
  #     run: |
  #       # Check for images with specific tag pattern
  #       IMAGE_TAG="${{ github.sha }}_servicenow"
  #       FULL_IMAGE_NAME="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

  #       # Check if image with this tag already exists
  #       if aws ecr describe-images \
  #         --repository-name ${{ env.ECR_REPOSITORY }} \
  #         --image-ids imageTag=$IMAGE_TAG \
  #         --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
  #         echo "image_exists=true" >> $GITHUB_ENV
  #         echo "EXISTING_IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
  #       else
  #         echo "image_exists=false" >> $GITHUB_ENV
  #       fi
      
  #       echo "FULL_IMAGE_NAME=$FULL_IMAGE_NAME" >> $GITHUB_ENV


  #   - name: Build, tag, and push a docker image to Amazon ECR if an docker image does not exist
  #     env:
  #       IMAGE_TAG: ${{ github.sha }}_servicenow
  #     if: env.image_exists == 'false'
  #     run: |
  #       # Build with multiple tags
  #       docker build \
  #         -t ${{ env.FULL_IMAGE_NAME }} \
  #         -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest \
  #         .
  #       echo "âœ… Docker image built and tagged"
      
  #   - name: Push Docker Image to Private ECR
  #     if: env.image_exists == 'false'
  #     run: |
  #         # Push with SHA tag
  #         docker push ${{ env.FULL_IMAGE_NAME }}
      
  #         # Push latest tag
  #         docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest
      
  #         echo "âœ… Image pushed successfully"
  #         echo "Image URI: ${{ env.FULL_IMAGE_NAME }}"
  
  #   - name: Skip Build if Image Already Exists
  #     if: env.image_exists == 'true'
  #     run: |
  #       echo "âœ… Image with tag ${{ env.EXISTING_IMAGE_TAG }} already exists in ECR"
  #       echo "Skipping build and push steps"


  #   - name: Verify ECR image
  #     if: env.image_exists == 'false' || env.image_exists == 'true'
  #     env:
  #       IMAGE_TO_TEST: ${{ env.image_exists == 'true' && format('{0}/{1}:{2}', env.ECR_REGISTRY, env.ECR_REPOSITORY, env.EXISTING_IMAGE_TAG) || env.FULL_IMAGE_NAME }}
  #     run: |
  #       echo "ğŸ”„ Logging into ECR..."
  #       aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
  #       docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
      
  #       echo "ğŸ“¦ Pulling image for verification: $IMAGE_TO_TEST"
  #       docker pull $IMAGE_TO_TEST
      
  #       echo "ğŸš€ Running container for health check..."
  #       # Run container in background
  #       docker run -d \
  #         -p 8080:8080 \
  #         --name verify-ecr-container \
  #         $IMAGE_TO_TEST
      
  #       # Wait for container to start
  #       sleep 60
      
  #       echo "ğŸ¥ Performing health check..."
  #       if curl -s -f http://localhost:8080/health; then
  #         echo "âœ… ECR image verification successful"
  #         echo "Health check passed"
  #       else
  #         echo "âŒ ECR image verification failed"
  #         echo "Container logs:"
  #         docker logs verify-ecr-container
  #       # Try alternative health endpoints
  #         echo "Trying alternative health endpoints..."
  #         curl -f http://localhost:8080/ || \
  #         curl -f http://localhost:8080/health || \
  #         curl -f http://localhost:8080/api/info|| exit 1
  #       fi
      
  #       # Cleanup
  #       echo "ğŸ§¹ Cleaning up verification container..."
  #       docker stop verify-ecr-container 2>/dev/null || true
  #       docker rm verify-ecr-container 2>/dev/null || true   

  # 2. éƒ¨ç½²åŸºç¡€è®¾æ–½ VPCï¼ˆç¬¬ä¸€æ¬¡ï¼‰
  deploy-infrastructure-vpc-stack:
    #needs: build-push-to-ecr
    runs-on: ubuntu-latest

    steps:

    - name: Checkout repository
      uses: actions/checkout@v2
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}

    - name: Check if VPC Stack Already Exists
      id: check_vpc
      run: |
        echo "ğŸ” Checking if VPC stack already exists..."   
        # First check if VPC stack exists at all
        if aws cloudformation describe-stacks --stack-name $VPC_STACK --region $AWS_REGION 2>/dev/null; then
        echo "âœ… VPC stack exists"
        echo "vpc_exists=true" >> $GITHUB_OUTPUT
        else
        echo "vpc_exists=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Deploy CloudFormation VPC Stack
      if: steps.check_vpc.outputs.vpc_exists == 'false'
      run: |
        
        echo "ğŸš€ Deploying infrastructure for production..."
        
        aws cloudformation deploy \
          --stack-name $VPC_STACK \
          --template-file infrastructure/vpc-isolated.yaml \
          --parameter-overrides \
            EnvironmentName=$EnvironmentName \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ secrets.REGION }} \
          --no-fail-on-empty-changeset
        
        # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
        echo "â³ Waiting for stack creation..."
        aws cloudformation wait stack-create-complete \
          --stack-name $VPC_STACK  \
          --region ${{ secrets.REGION }}
        
        echo "âœ… Infrastructure $VPC_STACK deployed successfully!"

  # 3. éƒ¨ç½²åŸºç¡€è®¾æ–½ ECS Clusterï¼ˆç¬¬ä¸€æ¬¡ï¼‰
  deploy-infrastructure-ecs-stack:
    needs: deploy-infrastructure-vpc-stack
    runs-on: ubuntu-latest

    steps:

    - name: Checkout repository
      uses: actions/checkout@v2
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}

    - name: Check if ECS Stack Already Exists
      id: check_ecs
      run: |
        echo "ğŸ” Checking if ECS cluster stack already exists..."   
        # First check if ECS cluster stack exists at all
        if aws cloudformation describe-stacks --stack-name $ECS_CLUSTER_STACK --region $AWS_REGION 2>/dev/null; then
        echo "âœ… ECS cluster stack exists"
        echo "ECSCluster_exists=true" >> $GITHUB_OUTPUT
        else
        echo "ECSCluster_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Deploy CloudFormation ECS cluster Stack
      if: steps.check_ecs.outputs.ECSCluster_exists == 'false'
      run: |
        
        echo "ğŸš€ Deploying infrastructure for production..."

            # æ­¥éª¤1: ç¡®ä¿ ECS æœåŠ¡é“¾æ¥è§’è‰²å­˜åœ¨
        echo "ğŸ” Checking ECS Service Linked Role..."
        if ! aws iam get-role --role-name AWSServiceRoleForECS --region $AWS_REGION 2>/dev/null; then
          echo "ğŸ“ Creating ECS Service Linked Role..."
          aws iam create-service-linked-role \
            --aws-service-name ecs.amazonaws.com \
            --region $AWS_REGION
          echo "âœ… ECS Service Linked Role created."
        else
          echo "âœ… ECS Service Linked Role already exists."
        fi

          # Get outputs from VPC stack
        VPC_ID=$(aws cloudformation describe-stacks \
          --stack-name  $VPC_STACK\
          --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        PRIVATE_SUBNETS=$(aws cloudformation describe-stacks \
          --stack-name $VPC_STACK \
          --query "Stacks[0].Outputs[?OutputKey=='PrivateSubnetIds'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        ECS_SG_ID=$(aws cloudformation describe-stacks \
          --stack-name $VPC_STACK \
          --query "Stacks[0].Outputs[?OutputKey=='ECSSecurityGroupId'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        PRIVATE_RT_ID=$(aws cloudformation describe-stacks \
          --stack-name $VPC_STACK \
          --query "Stacks[0].Outputs[?OutputKey=='PrivateRouteTableId'].OutputValue" \
          --output text \
          --region $AWS_REGION)
      
        echo "ğŸ“Š Retrieved parameters:"
        echo "VPC ID: $VPC_ID"
        echo "Private Subnets: $PRIVATE_SUBNETS"
        echo "ECS Security Group: $ECS_SG_ID"
        echo "Private Route Table: $PRIVATE_RT_ID"

        # Create parameters JSON file
        cat > parameters.json << EOF
        [
         {
          "ParameterKey": "EnvironmentName",
          "ParameterValue": "$EnvironmentName"
         },
         {
          "ParameterKey": "VpcId",
          "ParameterValue": "$VPC_ID"
         },
         {
          "ParameterKey": "PrivateSubnetIds",
          "ParameterValue": "$PRIVATE_SUBNETS"
         },
         {
          "ParameterKey": "ECSSecurityGroupId",
          "ParameterValue": "$ECS_SG_ID"
         },
        {
          "ParameterKey": "PrivateRouteTableId",
          "ParameterValue": "$PRIVATE_RT_ID"
         }
        ]
        EOF
    
        echo "ğŸ“„ Parameters JSON:"
        cat parameters.json
        
        # Try to create ecs stack 
        aws cloudformation create-stack \
          --stack-name $ECS_CLUSTER_STACK\
          --template-body file://infrastructure/ecs-cluster-vpce.yaml \
          --parameters file://parameters.json \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region $AWS_REGION 
    
        
        # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
        echo "â³ Waiting for stack creation..."
        aws cloudformation wait stack-create-complete \
          --stack-name $ECS_CLUSTER_STACK \
          --region ${{ secrets.REGION }}
        
        if [ $? -eq 0 ]; then
          echo "âœ… Infrastructure $ECS_CLUSTER_STACK deployed successfully!"
        else
          echo "âŒ Stack creation failed. Checking events..."  
          aws cloudformation describe-stack-events \
            --stack-name $ECS_CLUSTER_STACK \
            --region $AWS_REGION \
            --query "StackEvents[?ResourceStatus=='CREATE_FAILED']" \
            --output table
          exit 1
        fi

  # 4. Route 53

   deploy-infrastructure-Route53-stack:
    needs: deploy-infrastructure-ecs-stack
    runs-on: ubuntu-latest

    steps:

    - name: Checkout repository
      uses: actions/checkout@v2
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
        aws-region: ${{ secrets.REGION }}

    - name: Check if Route 53 Stack Already Exists
      id: check_Route53
      run: |
        echo "ğŸ” Checking if Route 53 stack already exists..."   
        # First check if Route 53 stack exists at all
        if aws cloudformation describe-stacks --stack-name $Route53_STACK --region $AWS_REGION 2>/dev/null; then
        echo "âœ… Route 53 stack exists"
        echo "Route53_exists=true" >> $GITHUB_OUTPUT
        else
        echo "Route53_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Deploy CloudFormation Route 53 Stack
      if: steps.check_Route53.outputs.Route53_exists == 'false'
      run: |
        
        echo "ğŸš€ Deploying infrastructure Route53 for production..."

        
        # Try to create Route 53 Stack
        aws cloudformation create-stack \
          --stack-name $Route53_STACK\
          --template-body file://infrastructure/route53-domain-dns.yaml \
          --capabilities CAPABILITY_IAM
          --region $AWS_REGION 
    
        
        # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
        echo "â³ Waiting for stack creation..."
        aws cloudformation wait stack-create-complete \
          --stack-name $Route53_STACK \
          --region ${{ secrets.REGION }}
        
        if [ $? -eq 0 ]; then
          echo "âœ… Infrastructure $Route53_STACK deployed successfully!"
        else
          echo "âŒ Stack creation failed. Checking events..."  
          aws cloudformation describe-stack-events \
            --stack-name $Route53_STACK \
            --region $AWS_REGION \
            --query "StackEvents[?ResourceStatus=='CREATE_FAILED']" \
            --output table
          exit 1
        fi

  # # 5. Application Load balancer setup 
  # deploy-infrastructure-appliationloadbalancer-stack:
  #   needs: deploy-infrastructure-ecs-stack
  #   runs-on: ubuntu-latest

  #   steps:

  #   - name: Checkout repository
  #     uses: actions/checkout@v2
    
  #   - name: Configure AWS Credentials
  #     uses: aws-actions/configure-aws-credentials@v1
  #     with:
  #       role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
  #       aws-region: ${{ secrets.REGION }}

  #   - name: Check if Application Load Balancer Already Exists
  #     id: check_applicatonLB
  #     run: |
  #       echo "ğŸ” Checking if Application Load Balancer stack already exists..."   
  #       # First check if Application Load Balancer stack exists at all
  #       if aws cloudformation describe-stacks --stack-name $Application_Load_Balancer_STACK --region $AWS_REGION 2>/dev/null; then
  #       echo "âœ… Application Load Balancer stack exists"
  #       echo "Application_Load_Balancer_exists=true" >> $GITHUB_OUTPUT
  #       else
  #       echo "Application_Load_Balancer_exists=false" >> $GITHUB_OUTPUT
  #       fi

  #   - name: Deploy Application_Load_Balancer Stack
  #     if: steps.check_applicatonLB.outputs.Application_Load_Balancer_exists == 'false'
  #     run: |
        
  #       echo "ğŸš€ Deploying infrastructure Application_Load_Balancer_exists for production..."

  #       # Get outputs from VPC stack
  #       VPC_ID=$(aws cloudformation describe-stacks \
  #         --stack-name  $VPC_STACK\
  #         --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" \
  #         --output text \
  #         --region $AWS_REGION)
      
  #       PUBLIC_SUBNETS=$(aws cloudformation describe-stacks \
  #         --stack-name $VPC_STACK \
  #         --query "Stacks[0].Outputs[?OutputKey=='PublicSubnetIds'].OutputValue" \
  #         --output text \
  #         --region $AWS_REGION)
      
  #       ApplicationLB_SG_ID=$(aws cloudformation describe-stacks \
  #         --stack-name $VPC_STACK \
  #         --query "Stacks[0].Outputs[?OutputKey=='ALBSecurityGroupId'].OutputValue" \
  #         --output text \
  #         --region $AWS_REGION)
      
      
  #       echo "ğŸ“Š Retrieved parameters:"
  #       echo "VPC ID: $VPC_ID"
  #       echo "Public Subnets: $PUBLIC_SUBNETS"
  #       echo "Application Load Balancer Security Group: $ApplicationLB_SG_ID"


  #       # Create parameters JSON file for application load balancer
  #       cat > parameters_applicationLB.json << EOF
  #       [
  #        {
  #         "ParameterKey": "EnvironmentName",
  #         "ParameterValue": "$EnvironmentName"
  #        },
  #        {
  #         "ParameterKey": "VpcId",
  #         "ParameterValue": "$VPC_ID"
  #        },
  #        {
  #         "ParameterKey": "PublicSubnetIds",
  #         "ParameterValue": "$PUBLIC_SUBNETS"
  #        },
  #        {
  #         "ParameterKey": "ALBSecurityGroupId",
  #         "ParameterValue": "$ApplicationLB_SG_ID"
  #        }
  #       ]
  #       EOF
    
  #       echo "ğŸ“„ Parameters JSON:"
  #       cat parameters_applicationLB.json
        
  #       # Try to create Application_Load_Balancer_STACK
  #       aws cloudformation create-stack \
  #         --stack-name $Application_Load_Balancer_STACK\
  #         --template-body file://infrastructure/alb-https.yaml \
  #         --parameters file://parameters_applicationLB.json \
  #         --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
  #         --region $AWS_REGION 
    
        
  #       # ç­‰å¾…æ ˆåˆ›å»ºå®Œæˆ
  #       echo "â³ Waiting for stack creation..."
  #       aws cloudformation wait stack-create-complete \
  #         --stack-name $Application_Load_Balancer_STACK \
  #         --region ${{ secrets.REGION }}
        
  #       if [ $? -eq 0 ]; then
  #         echo "âœ… Infrastructure $Application_Load_Balancer_STACK deployed successfully!"
  #       else
  #         echo "âŒ Stack creation failed. Checking events..."  
  #         aws cloudformation describe-stack-events \
  #           --stack-name $Application_Load_Balancer_STACK \
  #           --region $AWS_REGION \
  #           --query "StackEvents[?ResourceStatus=='CREATE_FAILED']" \
  #           --output table
  #         exit 1
  #       fi

#   # 5. æ›´æ–° ECS æœåŠ¡ä½¿ç”¨æ–°é•œåƒ
#   deploy-infrastructure-ecs-service-stack:
#     needs: [build-push-to-ecr, deploy-infrastructure-vpc-stack,deploy-infrastructure-ecs-stack]
#     runs-on: ubuntu-latest

    
#     steps:

#     - name: Checkout repository
#       uses: actions/checkout@v2
    
#     - name: Configure AWS Credentials
#       uses: aws-actions/configure-aws-credentials@v1
#       with:
#         role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
#         aws-region: ${{ secrets.REGION }}

#     - name: Check if ECS service Stack Already Exists
#       id: check_ecs_service
#       run: |
#         echo "ğŸ” Checking if ECS service stack already exists..."   
#         # First check if ECS service stack exists at all
#         if aws cloudformation describe-stacks --stack-name $ECS-Service-Stack --region $AWS_REGION 2>/dev/null; then
#         echo "âœ… ECS service stack exists"
#         echo "ECSService_exists=true" >> $GITHUB_OUTPUT
#         else
#         echo "ECSService_exists=false" >> $GITHUB_OUTPUT
#         fi

#     - name: Deploy CloudFormation ECS service Stack
#       if: steps.check_ecs_service.outputs.ECSService_exists == 'false'
#       run: |
#           aws cloudformation create-stack \
#           --stack-name $ECS-Service-Stack\
#           --template-body file://infrastructure/ecs-service-private.yaml \
#           --parameters file://parameters.json \
#           --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
#           --region $AWS_REGION 
    
#     - name: Get CloudFormation outputs
#       id: cf-outputs
#       run: |
#         ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
#         STACK_NAME="servicenow-$ENVIRONMENT"
        
#         echo "ğŸ“‹ Getting CloudFormation outputs..."
        
#         # è·å–æ ˆè¾“å‡º
#         OUTPUTS=$(aws cloudformation describe-stacks \
#           --stack-name $STACK_NAME \
#           --query 'Stacks[0].Outputs' \
#           --region ${{ env.AWS_REGION }} \
#           --output json)
        
#         # æå–å…³é”®è¾“å‡º
#         CLUSTER_NAME=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSClusterName").OutputValue')
#         SERVICE_NAME=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSServiceName").OutputValue')
#         ALB_DNS=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="ALBDnsName").OutputValue')
        
#         echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
#         echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
#         echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV
        
#         echo "âœ… Retrieved CloudFormation outputs:"
#         echo "   Cluster: $CLUSTER_NAME"
#         echo "   Service: $SERVICE_NAME"
#         echo "   ALB DNS: $ALB_DNS"
    
#     - name: Update ECS service with new image
#       run: |
#         ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        
#         echo "ğŸ”„ Updating ECS service with new image..."
        
#         # æ–¹æ³•1ï¼šç›´æ¥æ›´æ–°æœåŠ¡ï¼ˆæœ€ç®€å•ï¼‰
#         aws ecs update-service \
#           --cluster ${{ env.CLUSTER_NAME }} \
#           --service ${{ env.SERVICE_NAME }} \
#           --force-new-deployment \
#           --region ${{ env.AWS_REGION }}
        
#         echo "âœ… ECS service update initiated"
        
#         # æˆ–è€…æ–¹æ³•2ï¼šä½¿ç”¨æ–°ä»»åŠ¡å®šä¹‰ï¼ˆæ›´ç²¾ç¡®æ§åˆ¶ï¼‰
#         # è·å–å½“å‰ä»»åŠ¡å®šä¹‰
#         # TASK_DEF=$(aws ecs describe-task-definition \
#         #   --task-definition servicenow-$ENVIRONMENT-task \
#         #   --region ${{ env.AWS_REGION }} \
#         #   --query 'taskDefinition' \
#         #   --output json)
#         #
#         # æ›´æ–°é•œåƒå¹¶æ³¨å†Œæ–°ä»»åŠ¡å®šä¹‰
#         # ... ç„¶åæ›´æ–°æœåŠ¡ä½¿ç”¨æ–°ä»»åŠ¡å®šä¹‰
    
#     - name: Wait for deployment to stabilize
#       run: |
#         echo "â³ Waiting for ECS deployment to stabilize..."
        
#         # ç­‰å¾…æœåŠ¡ç¨³å®š
#         aws ecs wait services-stable \
#           --cluster ${{ env.CLUSTER_NAME }} \
#           --service ${{ env.SERVICE_NAME }} \
#           --region ${{ env.AWS_REGION }}
        
#         echo "âœ… ECS service stabilized"
        
#         # è·å–éƒ¨ç½²çŠ¶æ€
#         SERVICE_INFO=$(aws ecs describe-services \
#           --cluster ${{ env.CLUSTER_NAME }} \
#           --services ${{ env.SERVICE_NAME }} \
#           --region ${{ env.AWS_REGION }} \
#           --query 'services[0]')
        
#         DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
#         RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
#         DEPLOYMENTS=$(echo $SERVICE_INFO | jq -r '.deployments | length')
        
#         echo "ğŸ“Š Deployment Status:"
#         echo "   Desired tasks: $DESIRED_COUNT"
#         echo "   Running tasks: $RUNNING_COUNT"
#         echo "   Active deployments: $DEPLOYMENTS"

#   # 5. éªŒè¯éƒ¨ç½²
#   verify-deployment:
#     needs: update-ecs-service
#     runs-on: ubuntu-latest
#     environment: ${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
    
#     steps:
#     - name: Wait for ALB to propagate
#       run: |
#         echo "â³ Waiting for ALB DNS to propagate and health checks to pass..."
#         sleep 60
#         echo "âœ… Wait complete"
    
#     - name: Test deployment via ALB
#       run: |
#         ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
        
#         # å¦‚æœ ALB_DNS æ²¡æœ‰è®¾ç½®ï¼Œå°è¯•è·å–
#         if [ -z "${{ env.ALB_DNS }}" ]; then
#           echo "Retrieving ALB DNS..."
#           ALB_DNS=$(aws elbv2 describe-load-balancers \
#             --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
#             --region ${{ env.AWS_REGION }} \
#             --output text | head -1)
#         else
#           ALB_DNS="${{ env.ALB_DNS }}"
#         fi
        
#         echo "ğŸ” Testing deployment via ALB: $ALB_DNS"
        
#         # æµ‹è¯•å¥åº·ç«¯ç‚¹
#         MAX_ATTEMPTS=10
#         ATTEMPT=1
#         SUCCESS=false
        
#         while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
#           echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."
          
#           # ä½¿ç”¨ curl æµ‹è¯• HTTPS ç«¯ç‚¹
#           RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" "https://$ALB_DNS/health" --max-time 30 2>/dev/null || echo "HTTP_STATUS:000")
#           STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
          
#           if [ "$STATUS" = "200" ]; then
#             echo "âœ… Health check passed: HTTP 200"
#             SUCCESS=true
            
#             # æµ‹è¯•å…¶ä»–ç«¯ç‚¹
#             echo "Testing additional endpoints..."
            
#             # æ ¹ç«¯ç‚¹
#             ROOT_RESPONSE=$(curl -s "https://$ALB_DNS/" --max-time 10 2>/dev/null || echo "No response")
#             if [ -n "$ROOT_RESPONSE" ] && [ "$ROOT_RESPONSE" != "No response" ]; then
#               echo "âœ… Root endpoint responded"
#             fi
            
#             # API ä¿¡æ¯ç«¯ç‚¹
#             API_RESPONSE=$(curl -s "https://$ALB_DNS/api/info" --max-time 10 2>/dev/null || echo "No response")
#             if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "No response" ]; then
#               echo "âœ… API info endpoint responded"
#             fi
            
#             break
#           else
#             echo "â³ Health check: HTTP $STATUS"
#             sleep 15
#             ATTEMPT=$((ATTEMPT + 1))
#           fi
#         done
        
#         if [ "$SUCCESS" = false ]; then
#           echo "âŒ Deployment verification failed after $MAX_ATTEMPTS attempts"
          
#           # è·å– ECS ä»»åŠ¡ä¿¡æ¯å¸®åŠ©è°ƒè¯•
#           echo "Fetching ECS task details for debugging..."
          
#           TASK_ARN=$(aws ecs list-tasks \
#             --cluster ${{ env.CLUSTER_NAME }} \
#             --service ${{ env.SERVICE_NAME }} \
#             --query 'taskArns[0]' \
#             --region ${{ env.AWS_REGION }} \
#             --output text)
          
#           if [ -n "$TASK_ARN" ] && [ "$TASK_ARN" != "None" ]; then
#             echo "ğŸ“‹ Task ARN: $TASK_ARN"
            
#             # è·å–ä»»åŠ¡çŠ¶æ€
#             TASK_STATUS=$(aws ecs describe-tasks \
#               --cluster ${{ env.CLUSTER_NAME }} \
#               --tasks $TASK_ARN \
#               --region ${{ env.AWS_REGION }} \
#               --query 'tasks[0].lastStatus' \
#               --output text)
            
#             echo "ğŸ“Š Task Status: $TASK_STATUS"
            
#             # è·å–åœæ­¢åŸå› ï¼ˆå¦‚æœä»»åŠ¡å¤±è´¥ï¼‰
#             STOP_REASON=$(aws ecs describe-tasks \
#               --cluster ${{ env.CLUSTER_NAME }} \
#               --tasks $TASK_ARN \
#               --region ${{ env.AWS_REGION }} \
#               --query 'tasks[0].stoppedReason' \
#               --output text 2>/dev/null || echo "N/A")
            
#             if [ -n "$STOP_REASON" ] && [ "$STOP_REASON" != "None" ]; then
#               echo "âš ï¸ Stop Reason: $STOP_REASON"
#             fi
#           fi
          
#           # æ£€æŸ¥ ALB ç›®æ ‡ç»„å¥åº·çŠ¶æ€
#           echo "Checking ALB target group health..."
          
#           TG_ARN=$(aws elbv2 describe-target-groups \
#             --query "TargetGroups[?contains(TargetGroupName, '$ENVIRONMENT')].TargetGroupArn" \
#             --region ${{ env.AWS_REGION }} \
#             --output text | head -1)
          
#           if [ -n "$TG_ARN" ]; then
#             TG_HEALTH=$(aws elbv2 describe-target-health \
#               --target-group-arn $TG_ARN \
#               --region ${{ env.AWS_REGION }} \
#               --query 'TargetHealthDescriptions[].TargetHealth.State' \
#               --output json 2>/dev/null || echo "[]")
            
#             echo "ğŸ¯ Target Group Health States:"
#             echo $TG_HEALTH | jq -r '.[]'
#           fi
          
#           exit 1
#         fi
    
#     - name: Run comprehensive tests
#       run: |
#         ALB_DNS="${{ env.ALB_DNS }}"
#         if [ -z "$ALB_DNS" ]; then
#           ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
#           ALB_DNS=$(aws elbv2 describe-load-balancers \
#             --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
#             --region ${{ env.AWS_REGION }} \
#             --output text | head -1)
#         fi
        
#         echo "ğŸ§ª Running comprehensive API tests..."
        
#         # æµ‹è¯•å¤šä¸ªç«¯ç‚¹
#         ENDPOINTS=(
#           "/"
#           "/health"
#           "/api/info"
#         )
        
#         ALL_PASSED=true
        
#         for endpoint in "${ENDPOINTS[@]}"; do
#           URL="https://$ALB_DNS$endpoint"
#           echo ""
#           echo "Testing: $URL"
          
#           # ä½¿ç”¨è¶…æ—¶å’Œé‡è¯•
#           for i in {1..3}; do
#             RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\nTIME:%{time_total}" \
#               "$URL" \
#               --max-time 30 \
#               --retry 2 \
#               --retry-delay 1 \
#               2>/dev/null || echo -e "\nHTTP_STATUS:000\nTIME:0")
            
#             STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d':' -f2)
#             TIME=$(echo "$RESPONSE" | grep "TIME:" | cut -d':' -f2)
#             BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d' | sed '/TIME:/d')
            
#             if [ "$STATUS" = "200" ] || [ "$STATUS" = "201" ] || [ "$STATUS" = "204" ]; then
#               echo "âœ… $endpoint: HTTP $STATUS (${TIME}s)"
#               if [ -n "$BODY" ]; then
#                 echo "   Response: $(echo "$BODY" | head -c 100)..."
#               fi
#               break
#             elif [ $i -eq 3 ]; then
#               echo "âŒ $endpoint: Failed after 3 attempts (HTTP $STATUS)"
#               ALL_PASSED=false
#             else
#               echo "âš ï¸ $endpoint: Attempt $i failed (HTTP $STATUS), retrying..."
#               sleep 2
#             fi
#           done
#         done
        
#         if [ "$ALL_PASSED" = true ]; then
#           echo ""
#           echo "ğŸ‰ All API tests passed!"
#         else
#           echo ""
#           echo "âš ï¸ Some API tests failed"
#         fi

#   # 6. æ¸…ç†å’Œé€šçŸ¥
#   cleanup-and-notify:
#     runs-on: ubuntu-latest
#     needs: [verify-deployment, deploy-infrastructure-vpc-stack, build-push-to-ecr]
#     if: always()
    
#     steps:
#     - name: Create deployment summary
#       run: |
#         ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
#         DEPLOYMENT_STATUS="${{ needs.verify-deployment.result }}"
#         CURRENT_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
#         echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
#         echo "" >> $GITHUB_STEP_SUMMARY
        
#         echo "### ğŸ“Š Deployment Details" >> $GITHUB_STEP_SUMMARY
#         echo "- **Environment**: \`$ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
#         echo "- **Status**: $([ \"$DEPLOYMENT_STATUS\" = \"success\" ] && echo \"âœ… Success\" || echo \"âŒ Failed\")" >> $GITHUB_STEP_SUMMARY
#         echo "- **Timestamp**: $CURRENT_TIME" >> $GITHUB_STEP_SUMMARY
#         echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
#         echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
#         echo "- **Workflow**: [${{ github.workflow }} #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
#         echo "" >> $GITHUB_STEP_SUMMARY
        
#         echo "### ğŸ“¦ Image Information" >> $GITHUB_STEP_SUMMARY
#         echo "- **Source**: GHCR" >> $GITHUB_STEP_SUMMARY
#         echo "- **GHCR Image**: \`ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
#         echo "- **ECR Image**: \`${{ needs.sync-to-ecr.outputs.ecr_image_uri || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
#         echo "" >> $GITHUB_STEP_SUMMARY
        
#         if [ "$DEPLOYMENT_STATUS" = "success" ]; then
#           echo "### ğŸ”— Access URLs" >> $GITHUB_STEP_SUMMARY
          
#           # å°è¯•è·å– ALB DNS
#           if [ -n "${{ env.ALB_DNS }}" ]; then
#             ALB_DNS="${{ env.ALB_DNS }}"
#           else
#             # å°è¯•ä» AWS è·å–
#             ALB_DNS=$(aws elbv2 describe-load-balancers \
#               --query "LoadBalancers[?contains(LoadBalancerName, '$ENVIRONMENT')].DNSName" \
#               --region ${{ env.AWS_REGION }} \
#               --output text 2>/dev/null | head -1 || echo "Not available")
#           fi
          
#           if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "Not available" ]; then
#             echo "- **API Endpoint**: [https://$ALB_DNS](https://$ALB_DNS)" >> $GITHUB_STEP_SUMMARY
#             echo "- **Health Check**: [https://$ALB_DNS/health](https://$ALB_DNS/health)" >> $GITHUB_STEP_SUMMARY
#             echo "- **API Info**: [https://$ALB_DNS/api/info](https://$ALB_DNS/api/info)" >> $GITHUB_STEP_SUMMARY
#           else
#             echo "- **API Endpoint**: Not available yet" >> $GITHUB_STEP_SUMMARY
#           fi
          
#           echo "" >> $GITHUB_STEP_SUMMARY
          
#           echo "### ğŸ—ï¸ Infrastructure" >> $GITHUB_STEP_SUMMARY
#           echo "- **ECS Cluster**: \`${{ env.CLUSTER_NAME || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
#           echo "- **ECS Service**: \`${{ env.SERVICE_NAME || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
#           echo "- **CloudFormation Stack**: \`servicenow-$ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
          
#           echo "### ğŸ“ˆ Next Steps" >> $GITHUB_STEP_SUMMARY
#           echo "1. Monitor application logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
#           echo "2. Check ECS service metrics in AWS Console" >> $GITHUB_STEP_SUMMARY
#           echo "3. Set up alerts for service health" >> $GITHUB_STEP_SUMMARY
#           echo "4. Configure auto-scaling if needed" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
          
#           echo "ğŸ‰ **Deployment successful!** The application is now live and serving traffic." >> $GITHUB_STEP_SUMMARY
#         else
#           echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "**Possible issues:**" >> $GITHUB_STEP_SUMMARY
#           echo "1. CloudFormation stack deployment failed" >> $GITHUB_STEP_SUMMARY
#           echo "2. ECS task failed to start" >> $GITHUB_STEP_SUMMARY
#           echo "3. ALB health checks failing" >> $GITHUB_STEP_SUMMARY
#           echo "4. Network connectivity issues" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "**Troubleshooting steps:**" >> $GITHUB_STEP_SUMMARY
#           echo "1. Check CloudFormation stack events" >> $GITHUB_STEP_SUMMARY
#           echo "2. Review ECS task logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
#           echo "3. Verify ALB target group health" >> $GITHUB_STEP_SUMMARY
#           echo "4. Check security group configurations" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "âš ï¸ **Please check the logs above for detailed error messages.**" >> $GITHUB_STEP_SUMMARY
#         fi
        
#         echo "" >> $GITHUB_STEP_SUMMARY
#         echo "---" >> $GITHUB_STEP_SUMMARY
#         echo "*Deployment completed at $CURRENT_TIME*" >> $GITHUB_STEP_SUMMARY
    
#     - name: Send Slack notification (optional)
#       if: always()
#       env:
#         SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
#       run: |
#         if [ -n "$SLACK_WEBHOOK_URL" ]; then
#           ENVIRONMENT=${{ github.event.inputs.environment || github.ref_name == 'main' && 'staging' || 'production' }}
#           DEPLOYMENT_STATUS="${{ needs.verify-deployment.result }}"
#           COMMIT_LINK="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
#           WORKFLOW_LINK="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
#           if [ "$DEPLOYMENT_STATUS" = "success" ]; then
#             EMOJI="ğŸš€"
#             COLOR="good"
#             TITLE="Deployment Successful"
#             MESSAGE="Successfully deployed to *$ENVIRONMENT*"
#           else
#             EMOJI="âš ï¸"
#             COLOR="danger"
#             TITLE="Deployment Failed"
#             MESSAGE="Failed to deploy to *$ENVIRONMENT*"
#           fi
          
#           PAYLOAD=$(cat << EOF
#           {
#             "attachments": [
#               {
#                 "color": "$COLOR",
#                 "title": "$EMOJI $TITLE",
#                 "fields": [
#                   {
#                     "title": "Environment",
#                     "value": "$ENVIRONMENT",
#                     "short": true
#                   },
#                   {
#                     "title": "Status",
#                     "value": "$DEPLOYMENT_STATUS",
#                     "short": true
#                   },
#                   {
#                     "title": "Commit",
#                     "value": "<$COMMIT_LINK|${GITHUB_SHA:0:7}>",
#                     "short": true
#                   },
#                   {
#                     "title": "Triggered by",
#                     "value": "${{ github.actor }}",
#                     "short": true
#                   }
#                 ],
#                 "footer": "GitHub Actions",
#                 "ts": $(date +%s),
#                 "actions": [
#                   {
#                     "type": "button",
#                     "text": "View Workflow",
#                     "url": "$WORKFLOW_LINK",
#                     "style": "primary"
#                   },
#                   {
#                     "type": "button",
#                     "text": "View Commit",
#                     "url": "$COMMIT_LINK"
#                   }
#                 ]
#               }
#             ]
#           }
#           EOF
#           )
          
#           curl -X POST -H 'Content-type: application/json' --data "$PAYLOAD" $SLACK_WEBHOOK_URL
#           echo "Slack notification sent"
#         else
#           echo "Slack webhook not configured, skipping notification"
#         fi
    
#     - name: Clean up Docker images
#       if: always()
#       run: |
#         echo "ğŸ§¹ Cleaning up Docker images..."
        
#         # åˆ é™¤æµ‹è¯•å®¹å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
#         docker rm -f test-app verify-ecr 2>/dev/null || true
        
#         # æ¸…ç†æœªä½¿ç”¨çš„é•œåƒ
#         docker image prune -a -f
        
#         echo "âœ… Cleanup complete"

# # 7. å›æ»šä½œä¸šï¼ˆæ‰‹åŠ¨è§¦å‘ï¼‰
#   rollback:
#     runs-on: ubuntu-latest
#     if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback'
#     environment: ${{ github.event.inputs.environment || 'production' }}
    
#     steps:
#     - name: Checkout
#       uses: actions/checkout@v4
    
#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v4
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}
    
#     - name: Rollback to previous task definition
#       run: |
#         ENVIRONMENT=${{ github.event.inputs.environment || 'production' }}
        
#         echo "ğŸ”™ Rolling back ECS service in $ENVIRONMENT..."
        
#         # è·å–å½“å‰æœåŠ¡ä¿¡æ¯
#         CLUSTER_NAME="servicenow-$ENVIRONMENT-cluster"
#         SERVICE_NAME="servicenow-$ENVIRONMENT-service"
        
#         # è·å–å…ˆå‰çš„ä»»åŠ¡å®šä¹‰
#         PREVIOUS_TASK_DEF=$(aws ecs describe-services \
#           --cluster $CLUSTER_NAME \
#           --services $SERVICE_NAME \
#           --region ${{ env.AWS_REGION }} \
#           --query 'services[0].deployments[?status==\"PRIMARY\"].taskDefinition' \
#           --output text)
        
#         if [ -n "$PREVIOUS_TASK_DEF" ]; then
#           echo "Rolling back to: $PREVIOUS_TASK_DEF"
          
#           # æ›´æ–°æœåŠ¡ä½¿ç”¨å…ˆå‰çš„ä»»åŠ¡å®šä¹‰
#           aws ecs update-service \
#             --cluster $CLUSTER_NAME \
#             --service $SERVICE_NAME \
#             --task-definition $PREVIOUS_TASK_DEF \
#             --region ${{ env.AWS_REGION }}
          
#           echo "âœ… Rollback initiated"
#         else
#           echo "âŒ No previous task definition found for rollback"
#           exit 1
#         fi
    
#     - name: Wait for rollback to complete
#       run: |
#         ENVIRONMENT=${{ github.event.inputs.environment || 'production' }}
#         CLUSTER_NAME="servicenow-$ENVIRONMENT-cluster"
#         SERVICE_NAME="servicenow-$ENVIRONMENT-service"
        
#         echo "â³ Waiting for rollback to stabilize..."
#         aws ecs wait services-stable \
#           --cluster $CLUSTER_NAME \
#           --service $SERVICE_NAME \
#           --region ${{ env.AWS_REGION }}
        
#         echo "âœ… Rollback completed successfully"